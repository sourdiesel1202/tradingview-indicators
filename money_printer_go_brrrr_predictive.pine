//@version=5
indicator(title="Money Printer Go BRRRRRR Predictive", overlay=true)
// drawVerticalLine(offset,color) =>
    // line.new(bar_index[offset], low-LineLength, bar_index[offset], high+LineLength, color=color.new(color.yellow, 50), width=3)
// adx_lookback=input(4, "ADX Lookback")
// trend_lookback=input(1,"Trend Lookback")

// obv_percent = input(5, "OBV Percent")
trend_lookback=input(1,"Trend Lookback")

obv_percent = input(0.01, "OBV Delta Percent", "The percentage between obv and obv[1], exceed this value to consider OBV trend strong")
_adx = input(14,"ADX Value")
// debug = input(true, "Debug", "Enable Logging")
// [prior_dmilpus, prior_dmineg, prior_adx] = ta.dmi(14, 14)

//[macdLine, signalLine, histLine] = ta.macd(close, fastInput, slowInput, 9)
// obv = ta.obv
// prior_obv = ta.obv[1]
prediction_lookback = input(3, "Prediction Lookback", "The number of bars to look back to generate prediction ")
// bars_in_future=input(1, "Future Bars", "The number of bars in the future to predict")
_dmiplus = input(17, "DMI+ Signal")
_dmineg = input(17, "DMI- Signal")
dmi_delta = input(1, "DMI Delta")
dmi_rapid=input(5, "DMI Rapid Change", "The delta between DMI[1] and DMI. If this value is exceeded, flag reversal")
adx_rapid=input(0.5, "ADX Rapid Change", "The delta between ADX[1] and ADX. If this value is exceeded, flag reversal")
// is_sinking(_indicator, _lookback)=>
calculate_prediction(_mpb_adx, _mpb_obv, _mpb_dm, _mpb_macd, prior_bars ) =>
    prediction=0.0
    price_averge = 0.0//array.new_float(prediction_lookback)
    price_delta_average = 0.0//  array.new_float(prediction_lookback)
    highs_lows =  0.0//array.new_float(prediction_lookback)
    iterations = 0
    bars_in_future =3
    for i = 0 to prediction_lookback
        iterations := iterations +1
        price_averge := price_averge + (open[prior_bars+i+1]+close[prior_bars+i])/2
        price_delta_average := (close[prior_bars+i]-open[prior_bars+i+1]) + price_delta_average
        // price_delta_average := price_delta_average + (((open[i+1]+close[i])/2)-(((open[i+1]+close[i])/2)))
        // price_delta_average := price_delta_average + (((close[i]+open[i])/2)-((close[i+1]+open[i+1])/2))
        // price_delta_average := price_delta_average+open-open[1]
        highs_lows := highs_lows+(high[prior_bars+i]-low[prior_bars+i])

    // highs_lows/prediction_lookback]7
    //ok so to calculate the next i bars we need to take the price delta average
    // for i = 1 to bars_in_future
    //do first prediction
    first_pred_mid = (price_averge/(prediction_lookback+1))+(price_delta_average/(prediction_lookback+1))
    first_pred_high = ((highs_lows/(prediction_lookback+1))/2)+first_pred_mid
    first_pred_low = first_pred_mid -((highs_lows/(prediction_lookback+1))/2)

    //second predication
    second_pred_mid = ((price_averge+first_pred_mid)/(prediction_lookback+2))+(price_delta_average/(prediction_lookback+1))
    second_pred_high = ((highs_lows/(prediction_lookback+1))/2)+second_pred_mid
    second_pred_low = second_pred_mid - ((highs_lows/(prediction_lookback+1))/2)

    //third prediction
    third_pred_mid = ((price_averge+first_pred_mid+second_pred_mid)/(prediction_lookback+3))+(price_delta_average/(prediction_lookback+1))
    third_pred_high = ((highs_lows/(prediction_lookback+1))/2)+third_pred_mid
    third_pred_low =  third_pred_mid -((highs_lows/(prediction_lookback+1))/2)

    [ first_pred_high,first_pred_mid, first_pred_low, second_pred_high, second_pred_mid, second_pred_low, third_pred_high, third_pred_mid, third_pred_low]

calculate_macd_value(prior=0) =>
    slowlength = 26
    fastLength = 12
    MACDLength = 9
    fast_ma = ta.ema(close, fastLength)
    slow_ma = ta.ema(close, slowlength)
    macd = fast_ma - slow_ma
    signal = ta.ema(macd, MACDLength)
    // MACD = ta.ema(close, fastLength) - ta.ema(close, slowlength)
    // aMACD = ta.ema(MACD[1], MACDLength)
    // delta = MACD - aMACD
    // signal=ta.ema(aMACD, MACDLength)
    ema20 = ta.ema(close,20)
    // ok so the idea here is- is the macd over  the ema (signal) line
    _value =0.0
    hist = macd -signal
    //ok so first, add our positive vs negative flag

    if macd > signal //case for long position
        if macd > macd[2] //if the general trend is up
            if hist[1] < hist //so now we look at the histogram,
                if signal-macd > (signal-macd> 0 ? 1.0 : -1.0)//ensure the delta is actually worth noting
                    _value :=0.20
                else
                    _value :=0.12
            else //otherwise we are
                if signal-macd > (signal-macd> 0 ? 1.0 : -1.0)
                    _value :=0.12
                else
                    _value :=0.05
        else //otherwise, the general trend is down
            if signal-macd > (signal-macd> 0 ? 1.0 : -1.0)
                _value :=0.12
            else
                _value :=0.0

    else
        if macd < macd[2] // gemeral trend is down
            if hist[1] > hist //look at histogram
                if macd-signal > (macd-signal> 0 ? 1.0 : -1.0)
                    _value :=-0.20
                else
                    _value :=-0.12
            else
                if macd-signal > (macd-signal> 0 ? 1.0 : -1.0)
                    _value :=-0.12
                else
                    _value:=-0.05
        else
            // _value := -0.125
            if macd-signal > (macd-signal> 0 ? 1.0 : -1.0)
                _value :=-0.12
            else
                _value :=0.0
    //check for positive vs negative macd values
    if macd > 0
        _value := _value+0.05
    else
        _value := _value+-0.05

    //ok so if a crossover happened, take this as a strong trend
    if macd > signal and macd[1] < signal[1]
        _value:=0.25
    if macd < signal and macd[1] > signal[1]
        _value:=-0.25
    [_value]
calculate_obv_value(prior=0)=>
    obv = ta.obv
    // obv = ta.obv
    obv_delta= 0.0
    // obv_delta_p
    _value = 0.0
    // _obv_percent = 0.0
    delta_percent = 0.0
    delta_percent_prior = 0.0
    // multiplier = 1.0
    if obv > 0
        _value := _value+0.05
    else
        _value := _value-0.05
    obv_delta := obv-obv[1]
    obv_delta_prior = obv[1]-obv[2]

    if obv > obv[1]
        delta_percent := ((obv_delta > 0) ?obv_delta : obv_delta*-1)/(obv[1] > 0 ? obv[1]: obv[1]*-1)*100

    else
        delta_percent := (((obv_delta > 0) ?obv_delta : obv_delta*-1)/(obv[1] > 0 ? obv[1]: obv[1]*-1)*100) * -1

    if obv>obv[2]
        delta_percent_prior := ((obv_delta_prior > 0) ? obv_delta_prior : obv_delta_prior*-1)/(obv[2] > 0 ? obv[2]: obv[2]*-1)*100
    else
        delta_percent_prior := (((obv_delta_prior > 0) ?obv_delta_prior : obv_delta_prior*-1)/(obv[2] > 0 ? obv[2]: obv[2]*-1)*100) * -1

    if delta_percent > 0
        if delta_percent > obv_percent
            if obv > obv[2]
                if delta_percent_prior > obv_percent
                    _value :=0.245
                else
                    _value := 0.125
            else
                if delta_percent_prior > obv_percent
                    _value :=-0.1245
                else
                    _value :=-0.05

        else
            if delta_percent_prior > obv_percent
                _value:=0.245
            else
                _value :=0.125
    else
        if delta_percent < (obv_percent*-1)
            if obv < obv[2]
                if delta_percent_prior < (obv_percent*-1)
                    _value :=-0.245
                else
                    _value := 0.125
            else
                if delta_percent_prior < (obv_percent*-1)
                    _value :=0.1245
                else
                    _value := 0.05
        else
            if delta_percent_prior < (obv_percent *-1)
                _value :=-0.245
            else
                _value :=-0.125
    // obv = ta.obv
    // obv_delta= 0.0
    // // obv_delta_p
    // _value = 0.0
    // // _obv_percent = 0.0
    // delta_percent = 0.0
    // // multiplier = 1.0
    // if obv > 0
    //     _value := _value+0.05
    // else
    //     _value := _value-0.05
    // obv_delta := obv-obv[1]
    // if obv > obv[1]
    //     delta_percent := ((obv_delta > 0) ?obv_delta : obv_delta*-1)/(obv[1] > 0 ? obv[1]: obv[1]*-1)*100
    // else
    //     delta_percent := (((obv_delta > 0) ?obv_delta : obv_delta*-1)/(obv[1] > 0 ? obv[1]: obv[1]*-1)*100) * -1
    // if delta_percent > 0
    //     if delta_percent > obv_percent
    //         if obv > obv[2]
    //             _value :=0.245
    //         else
    //             _value :=-0.1245
    //     else
    //         _value:=0.05
    // else
    //     if delta_percent < (obv_percent*-1)
    //         if obv < obv[2]
    //             _value :=-0.245
    //         else
    //             _value :=0.1245
    //     else
    //         _value :=-0.05

    [_value]

calculate_adx_value(prior=0)=>
// [dmilpus, dmineg, adx] = ta.dmi(input(14,"DMI Length"), input(14, "ADX Smoothing"))
    [dmilpus, dmineg, adx] = ta.dmi(input(14,"DMI Length"), input(3, "ADX Smoothing"))

    _value=0.0
    if adx > adx[2] //we know trend is strong
        if adx > 20
            _value :=0.25
        else
            _value := 0.175
    else
        _value := -0.175

    // if dmineg > dmilpus
        // _value := _value *-1



    // if adx > adx[1]
    //     _value:=0.25

    // else
    //     if adx > adx[2]
    //         _value:=0.125
    //     if adx[1]-adx > adx_rapid
    //         _value:=0
    //     else
    //         _value:=0.125
    // if adx > adx[1]
    //     _value:=0.25
    // else
    //     sinking=true
    //     for i =0 to trend_lookback
    //         if sinking
    //             if adx[i+prior] > adx[i+1]
    //                 sinking:=false
    //     // _sinking = sinking

    //     if sinking
    //         _value:=0.0
    //     else
    //         _value :=0.125
    _value :=  dmilpus > dmineg ? 1*_value : -1*_value
    // plotchar(_value, "MPB ADX Value", "", location = location.top)
    [_value]
calculate_dmi_value()=>
    _value=0.0
    [dmilpus, dmineg, adx] = ta.dmi(input(14,"DMI Length"), input(14, "ADX Smoothing"))
    if dmilpus >= dmineg and dmilpus >= _dmiplus
        if dmilpus-dmineg > dmi_delta
            if dmilpus > dmilpus[2]
            // if dmilpus > dmilpus[1]
                _value:=0.25
            else
                _value:=0.0 //flag reversal
            // else

                    // _value:=0.25
                // else
                    // _value:=0
    //# check to see if dmi+ is trending down and dmi- is trending up
    // if dmilpus < dmilpus[1] and dmineg > dmineg[1]
        //plot(1,color = color.green)
        else
            _value:=0.125
        // if  prior_obv> obv and prior_obv/obv*100 < obv_percent
            // value:=0.5


    //case for rapid changes pointing to reversal
        if dmilpus[1]-dmilpus > dmi_rapid
            _value:=0
    // if dmilpus
    // if dmilpus-dmineg <= dmi_delta
        // value:=0
    // if dmilpus-dmineg < input(15, "DMI Delta")
    //     value:=0.5
    // else
    //     value := 0.5
    // []
    if dmineg >= dmilpus and dmineg >= _dmineg
        if dmineg-dmilpus > dmi_delta
            if dmineg > dmineg[2]
                _value:=-0.25
            else
                // if (dmineg+dmineg[1]+dmineg[2]) / 3 > dmineg
                //     _value:=-0.25
                // else
                _value:=0
        // if adx > prior_adx
        else
            _value:=-0.125
            // if  rsi >= input(60, "RSI High")
                // line.new(bar_index, close, bar_index, close + 1, xloc.bar_index, extend.both, color.red)
            // else
            //     value := -0.5
        if dmineg[1]-dmineg > dmi_rapid
            _value:=0
    [_value]


// old_value = 0.0


// //
// // BEGIN DEBUG LOGGING
// // uncomment below lines for debug logging (show values in data window)
// //

// first_pred_high =

[mpb_dmi] = calculate_dmi_value()
[mpb_adx] = calculate_adx_value()
[mpb_macd]=calculate_macd_value()
[mpb_obv]= calculate_obv_value()
// if debug
// plotchar(mpb_macd, "MPB MACD Value", "", location = location.top)
// plotchar(mpb_obv, "MPB OBV Value", "", location = location.top)
// plotchar(mpb_adx, "MPB ADX Value", "", location = location.top)
// plotchar(mpb_dmi, "MPB DMI Value", "", location = location.top)
// obv = ta.obv

value = mpb_adx+mpb_dmi+mpb_macd+mpb_obv
old_value = mpb_adx[1]+mpb_dmi[1]+mpb_macd[1]+mpb_obv[1]

[ first_pred_high,first_pred_mid, first_pred_low, second_pred_high, second_pred_mid, second_pred_low, third_pred_high, third_pred_mid, third_pred_low] = calculate_prediction(mpb_adx, mpb_obv, mpb_dmi, mpb_macd,1)

    // plotchar(iterations, "Iterations", "", location = location.top)
// plot(first_pred_mid, color = color.white)
plotchar(first_pred_high, "First predict High", "", location = location.top)
plotchar(first_pred_low, "First predict low", "", location = location.top)
// var line l  = na
// l := line.new(bar_index, first_pred_high, bar_index, first_pred_high, color=color.red)    //
// line.set_x2(l, bar_index)
plotchar(second_pred_mid, "Second predict", "", location = location.top)
plotchar(third_pred_mid, "Third predict", "", location = location.top)
dt = time - time[1]
first_high = line.new(time, first_pred_high, time+1 , first_pred_high, color = color.green, xloc = xloc.bar_time)
first_low = line.new(time , first_pred_low, time+1  , first_pred_low,  color = color.red, xloc = xloc.bar_time)
second_high = line.new(time + 1 * dt , second_pred_high, time + 2 * dt, second_pred_high, color = color.rgb(141, 183, 143),xloc = xloc.bar_time)
second_low = line.new(time + 1 * dt , second_pred_low, time + 2 * dt, second_pred_low,  color = color.rgb(255, 129, 129),xloc = xloc.bar_time)
third_high = line.new(time + 2 * dt, third_pred_high, time + 3 * dt, third_pred_high, color = color.rgb(214, 252, 215),xloc = xloc.bar_time)
third_low = line.new(time + 2 * dt, third_pred_low, time + 3 * dt, third_pred_low, color = color.rgb(238, 182, 182),xloc = xloc.bar_time)
// line.set_extend()
line.delete(first_high[1])
line.delete(first_low[1])
line.delete(second_high[1])
line.delete(second_low[1])
line.delete(third_high[1])
line.delete(third_low[1])
// line.delete(lowLine[1])
// hline(mpb_adx, title="First Prediction", color=color.gray, linestyle=hline.style_dashed, linewidth = 3.0)
// plot(first_pred_high, color = color.green, offset = 1)
// plot(first_pred_mid,title = "First Prediction", color = color.green , offset = 1)
// plot(first_pred_low, color = color.purple , offset = 1)
// plot(second_pred_mid, color = color.yellow,title = "Second Prediction")
// plot(first_pred_high, color = color.green, offset = 1)
// plot(second_pred_low, color = color.red, offset = 2)
// plot(second_pred_high, color = color.green, offset = 2)
// plot(third_pred_mid, color = color.gray,title = "Third Prediction")
// plot(third_pred_low, color = color.red, offset = 3)
// plot(third_pred_high, color = color.green, offset = 3)
// plotchar(iterations, "Iterations", "", location = location.top)

// plotchar(price_averge/(prediction_lookback+1), "Price Average", "", location = location.top)
// plotchar(price_delta_average/(prediction_lookback+1), "Price Delta", "", location = location.top)
// // plotchar(price_delta_average/(prediction_lookback+1), "Price Delta Average")
// plotchar(highs_lows/(prediction_lookback+1), "High/Low Delta Average", "", location = location.top)

// obv = ta.obv
// // obv = ta.obv
// obv_delta= 0.0
// // obv_delta_p
// _value = 0.0
// // _obv_percent = 0.0
// delta_percent = 0.0
// delta_percent_prior = 0.0
// // multiplier = 1.0
// if obv > 0
//     _value := _value+0.05
// else
//     _value := _value-0.05
// obv_delta := obv-obv[1]
// obv_delta_prior = obv[1]-obv[2]

// if obv > obv[1]
//     delta_percent := ((obv_delta > 0) ?obv_delta : obv_delta*-1)/(obv[1] > 0 ? obv[1]: obv[1]*-1)*100

// else
//     delta_percent := (((obv_delta > 0) ?obv_delta : obv_delta*-1)/(obv[1] > 0 ? obv[1]: obv[1]*-1)*100) * -1

// if obv>obv[2]
//     delta_percent_prior := ((obv_delta_prior > 0) ? obv_delta_prior : obv_delta_prior*-1)/(obv[2] > 0 ? obv[2]: obv[2]*-1)*100
// else
//     delta_percent_prior := (((obv_delta_prior > 0) ?obv_delta_prior : obv_delta_prior*-1)/(obv[2] > 0 ? obv[2]: obv[2]*-1)*100) * -1

// if delta_percent > 0
//     if delta_percent > obv_percent
//         if obv > obv[2]
//             if delta_percent_prior > obv_percent
//                 _value :=0.245
//             else
//                 _value := 0.125
//         else
//             if delta_percent_prior > obv_percent
//                 _value :=-0.1245
//             else
//                 _value :=-0.05

//     else
//         if delta_percent_prior > obv_percent
//             _value:=0.245
//         else
//             _value :=0.125
// else
//     if delta_percent < (obv_percent*-1)
//         if obv < obv[2]
//             if delta_percent_prior < (obv_percent*-1)
//                 _value :=-0.245
//             else
//                 _value := 0.125
//         else
//             if delta_percent_prior < (obv_percent*-1)
//                 _value :=0.1245
//             else
//                 _value := 0.05
//     else
//         if delta_percent_prior < (obv_percent *-1)
//             _value :=-0.245
//         else
//             _value :=-0.125
// plotchar(_value, "MPB OBV Value (Debug)", "", location = location.top)

// plotchar(obv, "OBV Value", "", location = location.top)
// plotchar(obv[1], "OBV[1] Value", "", location = location.top)
// plotchar(obv_delta, "OBV Delta", "", location = location.top)
// plotchar(delta_percent, "OBV Delta Percent", "", location = location.top)
// plotchar(delta_percent_prior, "OBV Delta Percent Prior", "", location = location.top)


// //MACD DEBUG
// slowlength = 26
// fastLength = 12
// MACDLength = 9
// fast_ma = ta.ema(close, fastLength)
// slow_ma = ta.ema(close, slowlength)
// macd = fast_ma - slow_ma
// signal = ta.ema(macd, MACDLength)
// // MACD = ta.ema(close, fastLength) - ta.ema(close, slowlength)
// // aMACD = ta.ema(MACD[1], MACDLength)
// // delta = MACD - aMACD
// // signal=ta.ema(aMACD, MACDLength)
// ema20 = ta.ema(close,20)
// // ok so the idea here is- is the macd over  the ema (signal) line
// _value :=0.0
// hist = macd -signal
// //ok so first, add our positive vs negative flag

// if macd > signal //case for long position
//     if macd > macd[2] //if the general trend is up
//         if hist[1] < hist //so now we look at the histogram,
//             if signal-macd > (signal-macd> 0 ? 1.0 : -1.0)//ensure the delta is actually worth noting
//                 _value :=0.20
//             else
//                 _value :=0.12
//         else //otherwise we are
//             if signal-macd > (signal-macd> 0 ? 1.0 : -1.0)
//                 _value :=0.12
//             else
//                 _value :=0.05
//     else //otherwise, the general trend is down
//         if signal-macd > (signal-macd> 0 ? 1.0 : -1.0)
//             _value :=0.12
//         else
//             _value :=0.0

// else
//     if macd < macd[2] // gemeral trend is down
//         if hist[1] > hist //look at histogram
//             if macd-signal > (macd-signal> 0 ? 1.0 : -1.0)
//                 _value :=-0.20
//             else
//                 _value :=-0.12
//         else
//             if macd-signal > (macd-signal> 0 ? 1.0 : -1.0)
//                 _value :=-0.12
//             else
//                 _value:=-0.05
//     else
//         // _value := -0.125
//         if macd-signal > (macd-signal> 0 ? 1.0 : -1.0)
//             _value :=-0.12
//         else
//             _value :=0.0
// //check for positive vs negative macd values
// if macd > 0
//     _value := _value+0.05
// else
//     _value := _value+-0.05

// //ok so if a crossover happened, take this as a strong trend
// if macd > signal and macd[1] < signal[1]
//     _value:=0.25
// if macd < signal and macd[1] > signal[1]
//     _value:=-0.25

// plotchar(hist, "MACD Histogram Value", "", location = location.top)
// plotchar(macd, "MACD Value", "", location = location.top)
// plotchar(_value, "MPB MACD Value (Debug) ", "", location = location.top)
// plotchar(signal, "MACD Signal Value", "", location = location.top)



// plot(0, color = color.purple)
// plot(1, color = color.purple)
// plot(-1, color = color.purple)
// plot(value, color = color.blue)
//plotchar(value, color = color.blue)


// plot(mpb_macd, color = color.yellow)
// plot(mpb_adx, color = color.white)
// plot(mpb_obv, color = color.green)
// plot(mpb_dmi, color = color.white)
// plot(mpb_adx, color = color.yellow)
//pl//ot(signalLine, color = color.orange)
